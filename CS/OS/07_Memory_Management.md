# 07_Memory_Management

메모리: 주소를 통해서 접근하는 장치

주소의 종류

- Logical address(=Virtual address)

  - 프로그램만의 독자적인 메모리 공간

  - ##### cpu가 보는 주소는 logical address이다

- Physical address
  - 메모리에 실제 올라가는 위치

- Symbolic Address
  - 프로스래머가 변수로 이름을 짓는 그런 것



## 주소 바인딩(주소 변환)

- Physical address에서 Logical address로 바뀌는 시점이 언제인가??

#### Compile time binding

- 컴파일 나는 시점에 이미 물리적인 주소까지 저장이되는 것
- 0은 OS가 들어가는 자리이기 때문에 현대에서는 사용하지 않는다

#### Load time binding

- 이 프로그램을 실행시키는 시점

#### Execution time binding(Runtime binding)

- 로드와 둘의 차이점
- 실행중에 주소가 바뀔 수 있음
- 수행이 시작된 이후에도 프로세스의 메모리상 위치를 옮길 수 있음
- cpu가 주소를 참조할 때마다 binding을 수시로 점검해야한다.
  - (가상메모리 주소가 물리적인 주소에서는 어디인지 봐야한다)라는 뜻
- 하드웨어적인 지원이 필요하다
  - 매번 주소변환이 필요하기 때문에



과정

![image-20220322094424780](07_Memory_Management.assets/image-20220322094424780.png)

- 왜 cpu는 로지컬 주소를 볼까??
  - 실제위치는 물리적 주소로 바뀐다
  - 하지만 안에 있는 주소는 가상메모리 주소이다
  - 컴파일에서 만들어진 주소이기 때문
  - 그래서 물리적인 메모리에서 40이 어디인지 찾아줘야한다
    - 예를 들어서 jump를 하고 싶음 그게 주소 40임
    - 어? 그럼 주소 40은 물리적인 메모리에서는 어디지??
    - 항상 변환을 해줘야한다.



### Memory-management Unit(MMU)

- 간단하게 설명
  - 현대에는 조금더 복잡하게 되어 있음
  - 가상 메모리 안에서 여러개로 쪼개져서 필요한 것들만 올라감
  - 하지만 이것은 간단한 스캠
- 사용자 프로그램
  - 논리적인 주소만 다룬다
  - 실제 물리적 주소를 볼 수 없음

![image-20220322103342187](07_Memory_Management.assets/image-20220322103342187.png)

- 레지스터 2개 있으면 된다

  - ##### relocation register

    - 시작 위치를 알고 있음
    - 가상 주소가 들어오면 거기다가 relocation에서 알려주는 값을 더해주면 물리메모리

  - ##### limit register

    - 논리적인 주소의 범위를 알려줌
    - 3000을 가지고 있으면
    - 14000에서 17000까지 주소의 범위를 제한한다.

![image-20220322103715337](07_Memory_Management.assets/image-20220322103715337.png)

- 똑같은 뜻



용어

- #### Dynamic Loading

  - Load는 메모리를 올린다는 뜻이다
  - 프로세스 전체를 메모리에 미리 다 올린는  것이 아님
  - 해당 루틴이 불려징 때 메모리에 load하는 것
  - 누가 해줌?
    - 운영체제 지원 프로그램 자체에서 구현 가능하다
    - 현대에는 조금 다르다
    - 하지만 지금은 운영체제가 하고 있음
  - 장점
    - memory utilization의 향상
    - 메모리의 낭비가 없어지기 때문에

- #### Overlay

  - 다이나믹 로딩이랑 똑같음
  - 옛날에는 메모리가 작았음 => 프로그래머가 수작업으로 했음
  - 그래서 이런 용어를 사용했음

- #### Swapping

  - 메모리에서 쫒아내는 것을 의미함

  - 디스크에 쫒아냄 (Backing store) = Swap area

  - 현대에는 부분부분 쫒아내게 된다. => 다른 용어가 있음 뒤에 할 것

  - ##### swap in/swap out

    - 중기 스케줄러에 의해 swap out시킬 프로세스 선정
    - 타켓을 우선순위로 정함
    - swap out은 메모리가 통째로 쫒겨난 것을 의미 한다
      - 그래서 현대에서 부분이 쫒아내면
      - page가 swap되었다라고 부르기도 한다
    - swapping이 지원 되려면 Run time binding으로 해줘야한다
      - 이유?
      - 쫒겨났다가 들어올때 비어있는 곳으로 들어오면 좋기 때문에
      - 즉 메모리 주소가 바뀌는 것이 낫기 때문이다
      - 메모리 주소 바뀌는 것 ? => Run time binding



- #### Dynamic Linking

  - 라이브러리를 연결하는 작동을 linking이라고 한다

  - ##### static linking (static library)

    - 라이브러리가 프로그램의 실행 파일 코드에 포함되어 있음

  - ##### Dynamic linking(shared library)

    - 라이브러리가 실행시 연결이 된다.
    - 실행파일에 포함되어있지 않음
    - 그래서 호출을 했을 때 그 때 그 라이브러리를 호출을 함
    - 그것을 찾기 위한 코드= **stub**이라고 함 
    - 만약 또 그 라이브러리를 부르게 된다??
      - 그럼 또 파일에 있는게 올라가는 것이 아님
      - 이미 올라가 있는거 가져다가 쓴다
      - 메모리를 아낄 수 있음



### Allocation of Physical Memory

- 사용자 프로세스 영역을 어떻게 관리 할 것인가?



#### Contiguous allocation

##### 현재 사용하지 않음

![image-20220322105931402](07_Memory_Management.assets/image-20220322105931402.png)

- 고정 분할 방식
  - 여러개 분할을 미리 나누어 놓음
  - 내부 조각이 생기기 때문에 비효율적임(낭비하는 메모리가 생김)
- 가변분할 방식
  - 그냥 올림
  - 문제점
    - 프로그램이 끝남
    - 그럼 그 공간이 빔
    - 근데 나중에 들어가는  프로그램의 크기가 작음
    - 외부공간이 생기게 됨
    - 그럼 메모리 낭비

- Hole
  - 이러한 조각들이 여러가지로 흩어지게 된다
  - 할당공간과 가용공간(hole)의 정보를 유지해야한다.
    - 왜?
    - 어디 어떤 홀에 메모리를 넣어야 효율적일지 생각을 해줘야 하기 때문에

![image-20220322110340151](07_Memory_Management.assets/image-20220322110340151.png)

- 홀 넣는 방법 3가지
  - First-fit
    - 최초로 찾아지는 곳에 넣음 빠름
  - Best-fit
    - 사이즈에 가장 적합한 곳을 찾음
    - 메모리 낭비가 낮음
    - 근데 다 탐색해야함
  - Worst-fit
    - 제일 큰 곳에 넣음 ==> 낭비가 큼

- compaction
  - 빈 공간을 모아서 큰 홀로 만들어주는 작업
  - 굉장한 비용이 든다
  - 따라서 최소한 메모리 이동으로 compaction을 하면됨
  - 하지만 너무 복잡함



#### Noncontiguous allocation

- 방법 3가지

  - Paging

  - Segmentation

  - paged Segmentation



#### Paging

![image-20220322135416784](07_Memory_Management.assets/image-20220322135416784.png)

- #### paging이란?

  - 프로세스의 각각의 가상메모리를 동일한 사이즈로 Page단위로 나눔
  - 당장 필요한 부분은 올려놓는다
  - 그리고 일부는 backing storage에 놓는다
  - 프로그램을 자른거임

- #### 물리적인 메모리

  - page와 동일한 크기의 Frame으로 나눔
  - 가상도 page로 나눔

- #### Page table

  - 이것을 통해서 주소변환을 한다.
  - 배열에서 각각의 번호를 인덱스 번호라고 한다.
  - table에서는 그것의 각각을 엔트리라고 한다.
  - 위 그림은 0번 엔트리, 1번 엔트리 ......이라고 한다.
  - 

- 장점
  - 외부조각이란?
    - 프로그램이 커서 맞지않는 크기에 들어가지 못함
  - 외부조각이 발생하지 않음
  - 하지만 내부조각이 발생 할 수 있음
    - 이유
    - 동일한 크기의 page단위로 자르다 보면 마지막에 남은 짜투리가 있음 이것을 내부조각이 있다라고 하는 것임





















