# 01_

- QueryDSL은 Git에서 관리하면 안된다.
- 자동으로 generate된 코드이기 때문이다.
- Build안에 generate했기 때문에 git ignore이 되어 있을 것이다.



## Lib

`com.querydls:querydsl-apt` : code genration 코드를 만들기 위한 것

`com.querydls:querydsl-jpa` : Application작성할 때 필요한 코드



## QueryDSL 기본문법

#### Q클래스

```java
QMember qMember = new QMember("m"); //별칭 직접 지정
QMember qMember = QMember.member;   //기본 인스턴스 사용
```

```java
import static jpa.practice2.jpa2.domain.queryDSL.QMemberQuery.*;

@Test
public void startQuerydsl(){
	// find member1
	// QMemberQuery m = new QMemberQuery("m");
	MemberQuery findMemberQuery = queryFactory
    		.select(memberQuery)
        	.from(memberQuery)
            .where(memberQuery.username.eq("member1")) 
            // parameter binding을 안해도 자동으로 해준다.
                .fetchOne();
        assertThat(findMemberQuery.getUsername()).isEqualTo("member1");
    }
```

- 기본 인스턴스를 사용 + static import로 바꿔서 사용하면 더 깔끔하게 사용할 수 있음
- 같은 테이블을 조인할 때는 `QMember qMember = new QMember("m");` 별칭을 사용해서 쓰면 된다.

```yaml
  jpa:
    hibernate:
      ddl-auto: create
    properties:
      hibernate:
        format_sql: true
        default_batch_fetch_size: 100
        use_sql_comments: true
        # 위를 사용하면 jpql이 로그로 찍히게 된다.
```



#### 검색쿼리

ex_

```java
@Test
public void search(){
    MemberQuery findMember = queryFactory
        .selectFrom(memberQuery)
        .where(memberQuery.username.eq("member1")
               .and(memberQuery.age.eq(10)))
        .fetchOne();
    assertThat(findMember.getUsername()).isEqualTo("member1");
}
```



**검색조건**

```java
member.username.eq("member1") 		// username = 'member1'
member.username.ne("member1") 		// username != 'member1'
member.username.eq("member1").not()  // username != 'member1'
    
member.username.isNotNull() 		// 이름이 is not null
    
member.age.in(10, 20) 			    // age in (10,20) => 10살 이거나 20살
member.age.notIn(10, 20) 			// age not in (10, 20)
member.age.between(10,30) 			// between 10, 30
    
member.age.goe(30) 				    // age >= 30 => 크거나 같거나
member.age.gt(30) 					// age > 30
member.age.loe(30) 					// age <= 30
member.age.lt(30) 					// age < 30
    
member.username.like("member%") 	 // like 검색
member.username.contains("member") 	 // like ‘%member%’ 검색
member.username.startsWith("member") // like ‘member%’ 검색
```



**and => , **

```java
    @Test
    public void search(){
        MemberQuery findMember = queryFactory
                .selectFrom(memberQuery)
//                .where(memberQuery.username.eq("member1")
//                        .and(memberQuery.age.eq(10)))
                .where(memberQuery.username.eq("member1"), // 위 방법과 동일하다.
                        (memberQuery.age.eq(10)))
                .fetchOne();
        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
```

- where() 에 파라미터로 검색조건을 추가하면 AND 조건이 추가됨 
- 이 경우 null 값은 무시 메서드 추출을 활용해서 동적 쿼리를 깔끔하게 만들 수 있음



#### 결과 조회

- **fetch( ) :**  
  - 리스트 조회
  - 데이터 X => 빈리스트 반환



- **fetchOne( )**
  - 결과 없으면 null
  - 둘 이상 => Error



- **fetchFirst( )**
  - limit(1).fetchOne( )



- **fetchResults( )**
  - 페이징 정보 포함
  - total count 쿼리 추가 실행
  - 성능이 중요한 paging을 활용해야할 때는 서로 다른 값을 내보낼 수 있다.
    - 성능 때문에
  - 따라서 이때는 쿼리 두개를 따로 보내야한다.

```java
@Test
public void resultFetch(){
    QueryResults<MemberQuery> results = queryFactory
        .selectFrom(memberQuery)
        .fetchResults();
    results.getResults();
    List<MemberQuery> content = results.getResults();
}
// 이렇게하면 쿼리를 두번 실행
// 1 => total이 있어야 paging할때 어디까지 페이지가 있는지 보여줄 수 있기 때문이다.
// 
```



- **fetchCount( )**
  - count 쿼리로 변경해서 count 수 조회



#### 정렬

```java
/**
 * 회원 정렬 순서
 * 1. 회원 나이 내림차순(desc)
 * 2. 회원 이름 올림차순(asc)
 * 단 2에서 회원 이름이 없으면 마지막에 출력(nulls last)
 */
@Test
public void sort(){
    em.persist(new MemberQuery(null,100));
    em.persist(new MemberQuery("member5",100));
    em.persist(new MemberQuery("member6",100));

    queryFactory
        .selectFrom(memberQuery)
        .where(memberQuery.age.eq(100))
        .orderBy(memberQuery.age.desc(), memberQuery.username.asc().nullsLast())
        .fetch();
}
```



#### 페이징

```java
// 원하는 곳을 페이징 할 경우
@Test
public void paging1() {
    List<MemberQuery> result = queryFactory
        .selectFrom(memberQuery)
        .orderBy(memberQuery.username.desc())
        .offset(1) //0부터 시작(zero index) => 하나를 스킵한다는 뜻이다.
        .limit(2) //최대 2건 조회
        .fetch();
    assertThat(result.size()).isEqualTo(2);
}

```

```java
// 전체 페이징을 원할 경우
// contents쿼리는 복잡
// count쿼리는 단순하게 짤 수 있을 때가 존재
// 따라서 나눠서 사용하는 것이 좋을 때가 있음
@Test
public void paging2() {
 QueryResults<Member> queryResults = queryFactory
         .selectFrom(member)
         .orderBy(member.username.desc())
         .offset(1)
         .limit(2)
         .fetchResults();
 assertThat(queryResults.getTotal()).isEqualTo(4);
 assertThat(queryResults.getLimit()).isEqualTo(2);
 assertThat(queryResults.getOffset()).isEqualTo(1);
 assertThat(queryResults.getResults().size()).isEqualTo(2);
}
```

-  **주의**
  - count 쿼리가 실행되니 성능상 주의!
    - 데이터를 조회하는 쿼리는 여러 테이블을 조인해야 하지만,  count 쿼리는 조인이 필요 없는 경우도 있다.
    - 이렇게 자동화된 count 쿼리는 원본 쿼리와 같이 모두 조인을 해버리기 때문에 성능이 안나올 수 있다
  - count 쿼리에 조인이 필요없는 성능 최적화가 필요하다면,  count 전용 쿼리를 별도로 작성해야 한다



#### 집합

```java
/**
     * JPQL
     * select
     * COUNT(m), //회원수
     * SUM(m.age), //나이 합
     * AVG(m.age), //평균 나이
     * MAX(m.age), //최대 나이
     * MIN(m.age) //최소 나이
     * from Member m
     */
@Test
public void aggregation() throws Exception {
    // 이렇게 여러가지를 가져오게 될때 => Tuple로 조회하게 된다.
    List<Tuple> result = queryFactory
        .select(memberQuery.count(),   // count
                memberQuery.age.sum(), // 합
                memberQuery.age.avg(), // 평균
                memberQuery.age.max(), // 맥스
                memberQuery.age.min()) // min
        .from(memberQuery)
        .fetch();
    
    Tuple tuple = result.get(0);
    
    assertThat(tuple.get(memberQuery.count())).isEqualTo(4);
    assertThat(tuple.get(memberQuery.age.sum())).isEqualTo(100);
    assertThat(tuple.get(memberQuery.age.avg())).isEqualTo(25);
    assertThat(tuple.get(memberQuery.age.max())).isEqualTo(40);
    assertThat(tuple.get(memberQuery.age.min())).isEqualTo(10);
}
```

- 이렇게 **여러가지**를 가져오게 될때 => **Tuple**로 조회하게 된다.
- DTO로 직접 뽑아오는 방법을 많이 사용하게 된다.



#### GroupBy사용

**group by**

```java
@Test
public void group(){
    List<Tuple> result = queryFactory
        .select(teamQuery.name, memberQuery.age.avg()) // 팀의 이름과 각 팀의 평균 연령
        .from(memberQuery) // member에서
        .join(memberQuery.teamQuery, teamQuery) // member의 팀이랑 팀이랑 조인
        .groupBy(teamQuery.name) // team의 이름과 그룹지어라
        .fetch();
}
```



**+ having**

```java
.groupBy(item.price)
.having(item.price.gt(1000))
```

- item.price로 그룹화해서 뽑아오는데 그것중에서 1000이 넘는 것만 뽑아라

















